---
layout: post
title: Always Be Publishing
excerpt: "What do you want to know about these techniques?"
modified: Thu Mar 2 09:52:40 CST 2017
categories: articles
tags: [api, github, docs, repos]
image:
  feature: seabamirum-common-redpoll.jpg
  credit: Flickr seabamirum
  creditlink: https://flic.kr/p/dFow3k
comments: true
share: true
---

# Always Be Publishing: Continuous Integration for REST API Docs

Key Takeaways

* API documentation provides a critical path for predicting customer success.
* Collaborating on documentation close to the code provides better reviews, more automation efficiencies, and enables doc quality tests.
* Provide common docs frameworks, standards, automation, and tools to give teams an efficiency boost.

Let's face it. Writing documentation can be downright boring sometimes. It is as exacting as the code itself. There are syntax errors and unwanted whitespace that you can introduce. Sometimes your ideas simply stop flowing, but you still need to fill in the blanks to make sure your docs are complete. With the growth of APIs as products, your documentation is more important than ever to create a successful API.

By writing documentation collaboratively as close to the code as possible, you can automate documentation tests, builds, and deployments. This approach provides many benefits: tested doc builds, continuous publishing, reviews of the docs and the code together, multiple outputs including tested code examples, release management, and prevents code from merging unless it has adequate documentation.

## Introduction to Docs CI/CD

For REST API documentation, three frameworks provide documentation output in the form of web pages, many of them interactive. These are OpenAPI(Swagger), RESTful API Modeling Language (RAML), and API Blueprint. OpenAPI, previously known as Swagger, is based on JSON, and because YAML is a superset of JSON, you can interchange the source files that describe the API. RAML is a YAML-based language to describe REST APIs. API Blueprint uses Markdown and can also adhere to <a href="https://help.github.com/categories/writing-on-github/">GitHub Flavored Markdown syntax</a>.

Many programming languages have a documentation framework that integrates well with the code itself. Typically these are static site generators, such as Jekyll for Ruby, and Sphinx for Python. The source files for the docs are Markdown or reStructured Text (RST). With these static site generators, you can make beautiful documentation sites. In fact, there's a <a href="https://github.com/PharkMillups/beautiful-docs">collection of links to beautiful docs on GitHub</a>.

Because these doc source files can be transformed using scripts, you can continuously build the documentation with the same build jobs as the code. Jekyll sites are deployed by copying flat files from a static directory, so you can store a script to build the site in the code repo with other build files. You can also have a simple link checker to test for any broken links before deploying the site. The `htmlproofer` is a Ruby library written to do just that.

The deployment mechanism provided by GitHub is called GitHub Pages. You have some options for triggering a docs deployment. You can automate builds from a `gh-pages` branch, from the `master` branch, or always deploy docs from a `/docs` directory on the `master` branch. Your GitHub repo has these options on the Settings page. While you can deploy to a custom domain name, one limitation for GitHub Pages currently is that you <a href="https://github.com/isaacs/github/issues/156">cannot serve directly through HTTPS</a>, but as a free service it's a good starting point. For production web sites, you can deploy from GitHub to a cloud server or VPS that has the security requirements you need. More or less, you are creating your own hosted web site.

## Why treat docs like code?

Writing with developers and for developers works well when the deliverables help developers. API documentation tasks provide a great example for why and when to treat docs like code. There are gains to be had when automating reference information, for example, and gains to be had by writing collaboratively. Also, one of the biggest success indicators for an API is the accuracy and helpfulness of the documentation. Here are some specific reasons to treat docs like code.

Collaboration: Having developers and technical writers write collaboratively provides both roles with valuable information. Developers want to write for an audience that resembles themselves, and can provide empathy for the reader. Writers have a special knack for organizing information, writing well, and revealing concepts and reference information in the proper order. Collaborating together in the same repository increases opportunities to both teach and learn.

Contributions: When you don't "throw writing over the wall" to a tech writing team, you can broaden the number of contributors, even if the API itself is not a public one with public documentation. Or, you can enable more contributions from the end-users themselves by providing open source docs repos in version control systems like GitHub. Any interested developers, including customers, can subscribe to notifications on pull requests when the docs are in the repo with the code.

Track bugs: For higher-quality docs, provide a way to report documentation bugs directly on the output page. As Linus's Law states, "given enough eyeballs, all bugs are shallow." By providing those eyeballs a place to report the bug, you give more code-like quality tracking to the docs. Plus, with metrics in place through issue tracking, you can measure the quality of the docs and ensure resources are in place when needed to squash those bugs.

Reviews: When reviewing docs that are included with code, reviewers can block a change to the code when the documentation is insufficient. This review guidance provides the team with the power to make the docs high quality, even when they have to be in synch with fast-moving code.

Tests and builds: By having a matched staging build for reviews and a production build for delivery to readers, you can be confident your review of built documentation meets user needs.

Deployments and releases: With docs like code, realize you are separating builds from deployments. This way, you can have reviews on early drafts of documentation and it does not become contractual until the doc build is deployed and released. Or, you can choose to release some documents continuously to keep up with the code. For example, you may choose to write narrative documentation and tutorials that release continuously with every landed patch set. But for contractual documentation like an OpenAPI specification, you can only deploy new documentation when the API is considered released at a specific version.

## Example tests for docs

You can test doc source files for quality and whether they build. You could also check for spelling or grammar, but typically human reviewers can do this also. The point for testing docs is to take that review burden off of human reviewers and let the automation save time so that more docs can be written and released.

### Link check

With many static site generators, there are libraries specifically for checking all the links in a site. For example, when checking links on a Jekyll web site like <a href="http://http://docslikecode.com">docslikecode.com</a>, the Travis CI job is simple:

```
#!/usr/bin/env bash
set -e # halt script on error

bundle exec jekyll build
bundle exec htmlproofer ./_site
```

With this type of test in place, human reviewers don't have to take the time to click every link in a new patch. If an external link should be updated, the results of this test let you know. If an internal link breaks due to the patch itself, the contributor can fix it before a human even needs to review the patch.

### JSON format

With REST API docs, the requests and responses are often JSON files and are valuable to readers so they can compare their own environment to the documentation. It's critical that the examples are formatted correctly in case a reader needs to copy and paste the request. In OpenStack, we have a set of common documentation tools that contain a JSON tester and formatter. By running this test on incoming patches to the docs, reviewers can determine if the included JSON files are accurate and formatted correctly. Plus, it makes the patch creation easier for a contributor when they can run a simple command locally to ensure the JSON format is correct.

### Validated requests and responses

An advanced documentation test can provide checks for the example requests and responses included in the documentation. When treating docs like code, accuracy is often the highest value. So, by testing examples against a working API endpoint, you can show that the examples will work in the real world as well. This type of validation provides trusted documentation examples that work every time, because they won't be published unless they pass the validation test.

### Build check

Automating the documentation tests frees up reviewer time because they do not have to build the docs themselves to review the output. In addition, you can test the build for broken doc links or improperly-formatted JSON files, for example. It's helpful to review both source documentation and output documentation for any oddities or problems.

## Conclusion

Working on documentation collaboratively in the same repositories as the code base provides opportunity to better serve customers. By treating your API docs like code, you can find automation opportunities, gain efficiencies, speed up documentation builds, and enable more reviewers and contributors.

